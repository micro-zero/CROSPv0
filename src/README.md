# Source code of CROSPv0

This directory includes source code of CROSPv0 written by
SystemVerilog HDL. The code basically groups by pipeline stages
and some common wrappers. The modules in sub-directories are
described below in order of pipeline stages.

## Frontend

Sub-directory `frontend` includes fetch unit and branch
predictor as the name depicts. The basic function of frontend
is to generate PC, fetch instruction stream from cache, and
generate instructions from this stream. Despite of the
inner-pipeline connections, frontend will also connect with
instruction cache. The branch predictor is currently simple
bimodal implementation and an important work for improvement in
the future.

## Decoder

Sub-directory `decoder` contains the decoder module to receive
input from frontend and provide u-operations for renaming. One
instruction will be devided to at most three u-operations. This
characteristic is mainly for floating-point multiply-add and
atomic instructions. Each operation loads at most two registers
in register file and write at most one register back. The file
`ci2i.sv` includes the module for converting a compressed
instruction to a normal one with combinational logic. Also, to
synchronize interrupts, when interrupt pending signal is
generated by CSR module, the decoder will only generate a HINT
instruction indicating the interrupt until interrupt taken and
enabling bits automatically unset to cancel this pending.

## Rename

CROSPv0 uses explicit renaming to resolve name dependency.
The rename module will use one stage to get physical register
names of source registers and allocate a new physical register
name for each operation from decoder. To support fast recovery
when encountering branch misprediction, snapshot of map table
is implemented in renaming module, in addition with normal
rollback mechanism to recover.

## issue

The issue unit of CROSPv0 currently consists of an out-of-order
queue and a FIFO for memory and CSR instructions. It detects
the readiness of function units and operands of each
instruction, and issues them to function units when ready.
This part may also requires proper improvement.

## Execute

Instructions issued are broadcast to all function units after
reading source registers and being combined with functional
codes. This broadcasting function is done by module in
`execute.sv`. This means shared register read ports by all
issue queues through an output arbiter after issue stage.
The function units will filter related operations and execute
them within several cycles. Due to the out-of-order execition,
a unique identifier will be allocated in decoder and also as
index in ROB to support write-back by different function units.
The function units of CROSPv0 includes ALU, LSU, MUL, DIV, and
FPU. Currently the FPU is only for simulation, and the
synthesizable code is only a placeholder. The current LSU is
also too simple to cope with complex programs. The improvement
will be considered next together with L1 memory system.

## Commit

Sub-directory `commit` includes codes related to instruction
committing and registers. After an operation is executed by
its function unit, at write-back stage the result will be
written back to destination physical registers and related bit
in reorder buffer will be set. If no exception raised in front
of ROB, the instruction at front will be committed. This marks
the completion and architectural change of each instruction.
To maintain speculative execution correctness and handle
exceptions, in commit module, the PC and exception bits will be
reflected in the output bundle of this module, and eventaully
broadcast to other modules to conduct pipeline redirection or
rollback. The busy table searched after renaming is physically
at PRF module inorder to share the similar input with PRF.

## Common

Some global code is in sub-directory `common`. Some are library
tools, such as multi-write-port RAM module used in some modules
to implement multi-write-port buffer, ROB and PRF. Some are
global definition of macros and types for convenience of data
transfers between modules.

## MMU

Memory operation are complicated and important enough to stand
as independent modules in sub-directory `mmu`. The memory
management unit handle requests from core and do translation,
ordering and accessing of instruction fetch and memory
operations. Currently the code are mixed in one file, and will
require a fine devision in the future to cooperate with LSU and
support speculative memory operation.

## SoC

In `soc` sub-directory are source code of components used in
SoC build. Some of them are dedicated for synthesis but not
simulation, such as SoC controller module because of the
strong platform-specific dependency. Others include core
wrappers and interrupt controller.
