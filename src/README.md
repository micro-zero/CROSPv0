# Source code of CROSPv0

This directory includes source code of CROSPv0 written by
SystemVerilog HDL. The code basically groups by pipeline stages
and some common wrappers. The modules in sub-directories are
described below in order of pipeline stages.

## Fetch

Sub-directory `fetch` includes fetch unit and branch predictor
as the name depicts. The basic function of fetch unit is to
generate PC, fetch instruction stream from cache, and generate
instructions from this stream. Despite of the inner-pipeline
connections, frontend will also connect with instruction cache.
The branch predictor is currently a TAGE implementation and an
important work for improvement in the future.

## Decoder

Sub-directory `decoder` contains the decoder module to receive
input from fetch unit and provide u-operations for renaming.
One instruction will be devided to at most three u-operations.
This characteristic is mainly for floating-point multiply-add
and atomic instructions. Each operation loads at most two
registers in register file and write at most one register back.
The file `ci2i.sv` includes the module for converting a
compressed instruction to a normal one with combinational
logic. Also, to synchronize interrupts, when interrupt pending
signal is generated by CSR module, the decoder will only
generate a HINT instruction indicating the interrupt until
interrupt taken and enabling bits automatically unset to cancel
this pending.

## Rename

CROSPv0 uses explicit renaming to resolve name dependency.
The rename module will use one stage to get physical register
names of source registers and allocate a new physical register
name for each operation from decoder. To support fast recovery
when encountering branch misprediction, snapshot of map table
is implemented in renaming module, in addition with normal
rollback mechanism to recover.

## issue

The issue unit of CROSPv0 currently a unified out-of-order
queue. It detects the readiness of function units and operands
of each instruction, and issues them to function units when
ready. Particularly, store operations are sent even when the
second operand, i.e. storing data, is not ready, and resent
when operands are both ready. This is to provide store
addresses as soon as possible to calculate address dependency
in load/store unit.

## Execute

Instructions issued are broadcast to all function units after
reading source registers and being combined with functional
codes. This broadcasting function is done by module in
`execute.sv`. This means shared register read ports by all
issue queues through an output arbiter after issue stage.
The function units will filter related operations and execute
them within several cycles. Due to the out-of-order execition,
a unique identifier will be allocated in decoder and also as
index in ROB to support write-back by different function units.
The function units of CROSPv0 includes ALU, LSU, MUL, DIV, and
FPU.

### ALU

ALU handles normal single-cycle instructions and interrupts. It
can operate multiple instructions to achieve superscalar
execution using Verilog generated block.

### LSU

Load store unit consists of load queue and store queue. The
indices of load and store instructions are allocated in
decoder. The addresses and store data are from issue unit when
oprands are ready. To earliest store instruction, when previous
operations are confirmed to be safe to commit, this store
instruction will be issued to MMU. To load instructions,
because of the support of speculative load, any load
instruction in load queue can be sent to MMU if ready. This may
lead to wrong speculation, and then LSU will send the execution
bundle again to notify ROB the exception. ROB will handle this
similar to an exception.

### MUL

Multiplier uses abstract multiplication operator in order to
imply DSP units in FPGA implementation. This is achieved by
calculating the result simply using multiplication operator,
and input it into a shift register with some latency. This
makes multiplier pipelined.

### DIV

Divider uses iterative subtraction algorithm. It tries out each
bit in quotient. The cycle number of an division operation is
uncertain for the optimization of skipping leading zeros is
applied.

### FPU

FPU is pipelined into several stages, including splition,
alignment, calculation, uniformization and conversion.
Normal operation can make use of these stages optionally.
Different from the normal floating-point operations, the FP
multiplication, FP division, and FP square root calculation do
not use normal FP pipeline. The multiplication and division use
same algorithm with integer operations after some conversion,
while square root is calculated by trying out each bit similar
with division algorithm.

## Commit

Sub-directory `commit` includes codes related to instruction
committing and registers. After an operation is executed by
its function unit, at write-back stage the result will be
written back to destination physical registers and related bit
in reorder buffer will be set. If no exception raised in front
of ROB, the instruction at front will be committed. This marks
the completion and architectural change of each instruction.
To maintain speculative execution correctness and handle
exceptions, in commit module, the PC and exception bits will be
reflected in the output bundle of this module, and eventaully
broadcast to other modules to conduct pipeline redirection or
rollback. The busy table accessed after renaming is physically
at PRF module in order to share the similar input ports of PRF.

## Common

Some global code is in sub-directory `common`. Some are library
tools, such as multi-write-port RAM module used in some modules
to implement multi-write-port buffer, ROB and PRF. Some are
global definition of functions, modules, macros and types for
convenience of reusing and data transfer between modules.

## MMU

Memory operation are complicated and important enough to stand
as independent modules in sub-directory `mmu`. The memory
management unit handle requests from core and do translation
and access of instruction fetch and memory operations. The
basic components are cache and TLB. Cache is set-associative
and non-blocking. Cache and TLB can both be configurable. MMU
instantiate cache module as instruction cache and data cache.
And then it convert the requests to AXI transactions. TLB
includes ITLB, DTLB and STLB. ITLB and DTLB are
fully-associative and STLB is set-associative. STLB connects to
page table walker, which is also implemented in MMU module.

## SoC

In `soc` sub-directory are source code of components used in
SoC build. The SoC components include interrupt controllers,
coherence hub and peripherals.
