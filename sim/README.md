# Simulation of CROSP SoC

This directory includes code for Verilator simulation.

## Hierarchy

The source files are listed below:

- `vcore.sv`: Additional wrapper of core, for extraction of
  verification states by HDL code. Currently the only
  implementation of CROSP core is `crosplite`.
- `soc.cpp`: together with `soc.h` includes the definition of
  several SoC components in HDL, including verification core
  and interrupt controller.
- `verif.cpp`: Together with `verif.h`, includes abstract AXI
  device class and definition of abstract physical memory, to
  handle memory R/W and other abstract memory-mapped operations
  such as UART-lite protocol. There is also definition of
  machine state and delta for verification, together with some
  utility functions to calculate and log state transitions.
- `main.cpp`: It includes the main function to handle command
  line, instantiate and initialize all components, run
  simulation and handle interconnects. During simulation, an
  optional checker is provided for verification.
- `sim.cpp`: This source file can build a simulator using
  verification tools in `verif.cpp` to run program in pure C++
  independently without HDL simulation. It can be seen as the
  reference model used in core verification.

## Build

The simulation uses Verilator, and for testing, RISC-V
toolchain is also recommanded to be installed. A pre-built
docker image can be found at
[dockerhub](https://hub.docker.com/r/microzero/riscv-sim). Run
```
docker run -it -v .:/work microzero/riscv-sim:verilator
```
to create and run a container. After toolset is properly
installed, run
```
make -j8
```
to build executable `main` to simulate with Verilator. Run
`./main -h` to show details of command line.

Some variables are supported in makefile to determine basic
parameters and pre-define some simulation behavior. Firstly the
parameters of SystemVerilog modules are defined in makefile
which can be changed directly or overwritten in command line.

## Verification flow

There are four steps in current verification flow.

1. Hex code test, run `make hex` to verify all hex codes.
2. RV standard test, run `make rv` to verify all rv codes.
3. Proxy kernal test, run `make pk PKARG="..."` to run PK.
4. Buildroot test.

The above procedure is related to three types of initializing
memory.

1. HEX mode: Read from text file including hex codes.
2. ELF mode: Read from ELF (executable linkable file).
3. BIN mode: Read from binary file.

HEX mode is designed to verify some basic correctness like
connection and data path, it can be generated by assembler or
compiler from user-defined code.

ELF mode is mainly to adapt standard programs and verification
tools, such as
[RISC-V tests](https://github.com/riscv-software-src/riscv-tests)
and other bare-metal programs like proxy kernel and OpenSBI
programs.

BIN mode is mainly to verify functions related to synthesis,
as it is simple enough to load into memory. In linux the initrd
are located at top of physical memory, and code is located at
bottom of physical memory. So in current BIN mode, to use
single binary file for initialization, memory are loaded from
initrd address, and loops back after reaching memory bound.
So the generation and loading of binary file must remain
coherent. Currently the generation fixes the size by 32M for
both vmlinux code and initrd.

Additionally, to support PK and Buildroot, two special memory
loading are supported.

1. DTB: Load device tree blob to address specified in makefile.
2. INITRD: Load initrd file to address specified in makefile.

Here are some examples for different test steps.

### Hex code test

Run `make hex` first, if error detected in a program,
`../util/code/hex/0.hex` for instance, we can run into this
specific program and debug. Run
```
./main -s -v -w -hex ../util/code/hex/0.hex
```
and the flag `-v` will log every committed instructions before
the error being detected. `-w` is to output waveform with names
`intc.vcd` and `vcore.vcd`.

### RV test

Run `make rv` first, and next step is similar with hex code.
For example, benchmark test `dhrystone` encounters error and
exit at cycle `200000`, and it may be unrealistic to record
waveform for such long time. So run
```
./main -s -v -w -t 199000 -1 \
    $RISCV/target/share/riscv-tests/benchmarks/dhrystone.riscv
```
and the simulation will start log and record waveform from
cycle `199000` to `-1` (unsigned integer maximum).

### PK test

Proxy kernel is part of RISC-V test suite which can be found in
[github](https://github.com/riscv-software-src/riscv-pk). It is
an application execution environment which can host
statically-linked ELF files and proxy system some calls with
support of host machine. After PK is installed at default
position, we can use
```
make -C ../util/code/user/
make pk PKARG="../util/code/user/arg hello world"
```
for example to run code with arguments specified in `PKARG` in
user mode and virtual address space.

### Buildroot test

First, we need to build Buildroot images. Run
```
git clone https://github.com/buildroot/buildroot.git
```
and checkout to version 2024.5. The version thereafter seems to
has issue with HTIF console protocol in spike configuration.
After RISC-V toolchain and Buildroot prerequisites are properly
installed, run
```
make spike_riscv64_defconfig
```
to generate a default spike configuration file. Then run
```
make menuconfig
```
in an x11 display environment or just edit the configuration to
modify instruction set to IMAC (before floating-point operations
are fully supported) and add some packages like coremark and
dhrystone. After that, run
```
make -j32 FORCE_UNSAFE_CONFIGURE=1
```
to build images and this may take some time.

To run Buildroot image, we should bypass HTIF registers to
handle console requests. Run
```
make PWD=2 -j8
```
for example to build simulation with a dual-issue core.

After images and simulation program are built, run
```
./main -dump path-to-example.img -s \
    -dtb     ../util/dt/spike.dtb \
    -initrd  path-to-example.cpio \
    -elf     path-to-example.elf
```
to create initial memory image using `-dump` flag and boot OS.
If we already have this image, alternatively we can simply run
```
./main -s -bin path-to-example.img 2>/dev/null
```
The `-s` is for simualtor checking. Output from code is
redirected to `stdout` even when the program issuing a write
system call to other file descriptor, meanwhlile the output
from simulation program is redirected to `stderr` including log
and debug information. Users can make use of this to separate
or hide logs by redirect `stderr` to other files such as
`/dev/null`.
